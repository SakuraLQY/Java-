## JVM虚拟机



![image-20221227094839077](E:\img\image-20221227094839077.png)

### JVM组成部分：

![image-20221227095547167](E:\img\image-20221227095547167.png)

#### 1.程序计数器

![image-20221227100510294](E:\img\image-20221227100510294.png)

- 作用，**是记住下一条JVM指令的内存地址**；1.多线程情况下，程序计数器用于记录当前线程执行的位置，从而线程切换回来的时候能够知道线程上次运行到哪儿了。2.字节码解释器通过改变程序计数器来依次读取指令，实现代码的流程控制。
- 特点
  - 是线程私有的，
  - 不会存在内存溢出的问题

#### 2.虚拟机栈

- 栈 - **线程运行**需要的内存空间；一个栈中具有多个栈帧
- 栈帧 - **每个方法**运行时需要的内存；栈帧中又有（参数、局部变量、返回地址)。 

- 每个线程只能有一个活动栈帧，对应着当前正在执行的方法

>**方法调用的数据需要通过栈进行传递**;每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出.
>
>**生命周期**：随着线程的创建而创建，随着线程的死亡而死亡



![image-20221227152421492](E:\img\image-20221227152421492.png)

**局部变量表**：存放了编译时期可知的各种数据类型(boolean\byte\char\short\int\float\long\double)、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**操作数栈**：主要作为方法调用中转站进行使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。

**动态链接** 主要服务一个方法需要调用其他方法的场景。在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。

![image-20221227153006797](E:\img\image-20221227153006797.png)

##### 问题辨析

1. 垃圾回收是否设计栈内存？

> 栈就是方法间的调用；垃圾回收不需要涉及

2. 栈内存分配越大越好吗？

> 栈默认大小为1M,线程运行需要的是栈空间，而物理机的内存大小是固定的，栈内存大，对应的栈数量就越少；

3. 方法内的局部变量是不是安全的；

>主要看方法中的局部变量是否是被共享的，每次调用方法都是创建一个新的栈，局部变量是线程私有的。
>
>如果方法局部变量没有逃离方法的作用访问，它是线程安全的
>
>如果如下图中在参数传递，和作为返回值有可能被其他线程拿到对应的引用地址，也就是如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全

![image-20221227105151801](E:\img\image-20221227105151801.png)

-

![image-20221227105437572](E:\img\image-20221227105437572.png)

#### 2.1 栈内存溢出

- 方法自己调用自己（出现stack overFlow）

![image-20221227110718379](E:\img\image-20221227110718379.png)

设置虚拟机内存属性

![image-20221227111644245](E:\img\image-20221227111644245.png)

当内存过小，也会出现栈内存溢出；

- 出现对象循环引用的时候，也会栈溢出

![image-20221227120023632](E:\img\image-20221227120023632.png)

**`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。

**`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

#### 2.2 线程运行诊断

**案列1： CPU运行过高**

![image-20221227154132003](E:\img\image-20221227154132003.png)

**定位：**

1.用top定位是哪个进程对cpu的占用过高

2.查看线程使用率：ps H -eo pid,tid,%cpu | grep 32655

3.jstack id进程

​	1. 可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号

**案例2：程序运行很长时间都没有返回结果**

排查死锁问题

- jstack pid

![image-20221227155220087](E:\img\image-20221227155220087.png)

#### 3.本地方法栈

- 与虚拟机栈发挥的作用极为相似，区别是：虚拟机栈为虚拟机执行java方法（即字节码服务），而*本地方法栈*则为**虚拟机使用到的Native方法服务。**

![image-20221227162210728](E:\img\image-20221227162210728.png)

#### 4.堆

**定义**:通过new关键字，创建对象都会使用存放在堆内存中

> Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法**，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间**。进一步划分的目的是更好地回收内存，或者更快地分配内存

------

在JDK7及JDK7版本之前，堆通常被分为以下三部分：

1. 新生代内存（Young Generation)
2. 老生代（Old Generation)
3. 永久代 （Permanent Generation)

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![image-20221227203532711](E:\img\image-20221227203532711.png)

**JDK8版本后PermGen(永久)已被Metaspace（元空间）取代，元空间使用的是直接内存**

大部分情况，**对象都会首先在 Eden 区域分配**，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 **1**(Eden 区->Survivor 区后对象的初始年龄变为 1)，**当它的年龄增加到一定程度（默认为 15 岁）**，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

##### 4.1 堆内存的溢出

![image-20221227162647106](E:\img\image-20221227162647106.png)

![image-20221227162718109](E:\img\image-20221227162718109.png)

- 通过设置Xmx8m后

![image-20221227163545364](E:\img\image-20221227163545364.png)

##### 4.2 堆内存诊断工具

1.jps工具

查看当前系统中有哪些java进程

2.Jmap工具

查看堆内存占用情况

3.jconsole工具

图形界面，多功能检测工具，可以连续检测

![image-20221227170833198](E:\img\image-20221227170833198.png)

调用jmap - heap 12113查看内存

![image-20221227171811916](E:\img\image-20221227171811916.png)

- 使用一个更好的可视化jvisualvm ,来定位到底是哪个导致的堆溢出

![image-20221227192711097](E:\img\image-20221227192711097.png)



![image-20221227195952304](E:\img\image-20221227195952304.png)